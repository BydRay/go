#############################
go 老男孩教育Go语言第一期



#############################
why go

day 1
	go 静态编译，不需要在运行时判断变量的类型，强类型语言的优势

	编译要求{要跟在函数后面，不能另起一行，阅读方便

	存在未使用的变量或未使用的包，则编译不通过，减少冗余代码，降低代码维护成本

	内存自动回收，只需要new分配内存，不需要释放

	从语言层面支持并发，并发编程简单



#############################
day 1

搭建开发环境

vs插件安装
	https://www.jianshu.com/p/be432e57acd2

nginx  强调多进程的架构
redis  单进程单线程的架构    服务器就需要多起几个实例

go 静态编译，不需要在运行时判断变量的类型，强类型语言的优势

编译要求{要跟在函数后面，不能另起一行，阅读方便

存在未使用的变量或未使用的包，则编译不通过，减少冗余代码，降低代码维护成本

内存自动回收，只需要new分配内存，不需要释放

从语言层面支持并发，并发编程简单

其他语言要写一个高并发的服务，就必须以维护一个线程池，go不需要，go的线程更轻量化，且go自己维护一个线程池

go 的并发基于CSP（Communicating Sequential Process）模型实现
	CSP理解：多个goroute之间通过channel进行通信，每个goroute都是轻量级高性能的

命令行 gofmt -w file.go   规范化代码，解决缩进、空行什么的

go 可以一个函数返回多个值，c 不可以

包的概念
	1. 和python一样，把相同功能的代码放到一个目录，称之为包
	2. 包可以被其他包引用
	3. main包是用来生成可执行文件，每个程序只有一个main包
	4. 包的主要用途是提高代码的可复用性

go 的编码永远都是utf-8

环境变量GOPATH用于指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作区，可以在GOPATH中设置多个工作区

go 开发目录结构
	d:/project/src/go_dev/day1/example1/hello.go
		      /bin/
		      /vender/        // 第三方包
		      /pkg/           // 静态库
	export GOPATH=d:/project/

构建 
	C:\Users\user\Desktop\go\project> go build -o bin/hello.exe dev/day1/hello
	go build 默认到src下面区找，所以go build 输入路径不用在前面加上src
	
go run file.go   类似执行一个脚本获取结果

 


#############################
go day 2 

go 编译，包名未main，有func main()，则编译生成可执程序，否则生成lib库

go 编译性语言，任何执行语句不能放在函数体之外，这是编译型语言和解释性语言的一个重要区别
	var name string
	name = "xxx"
	编译报错，需要写个函数，到函数里面去初始化

包别名
	import(
	    a  "add"
	)
	import(
	    _  "add"       //仅导入这个包，不引用里面的任何一个变量和函数，这么做可以通过编译
	)
 
每个源文件都可以包含一个init函数，这个init函数自动被go运行框架调用。

常量使用const 修饰，代表永远是只读的，不能修改。
	const 只能修饰boolean，number（int相关类型、浮点类型、complex）和string
	const identifier [type] = value，其中type可以省略。
		const a string = "xxx"
		const b = "xxx"    
		const c = 9/3 
		const (
			a string = "xxx"
			b = "xxx"    
			c = 9/3 
		)

var(
	a int      // 默认为0
	b string   // 默认为“”
	c bool     // 默认为false
	d = 8
	e = "hello"   // 没类型也行，默认做类型推导
)
		
值类型：基本数据类型int、float、bool、string以及数组和struct。 值类型的内存通常在栈中分配。
引用类型：指针、slice、map、chan等都是引用类型。  引用类型的内存通常在堆上分配。

栈，如执行到一条函数语句，则先用栈保存传入的参数，然后跳到函数的地址，然后再将参数出栈，go 的栈空间一般是几K
堆  物理内存，需要动态申请，用完要释放，多个线程共用，需要加锁，分配性能没有栈高

变量作用域 块作用域

数字类型，主要有int、int8、int16、int32、int64、uint8、uint16、uint32、uint64、float32、float64
	var a float   // 出错

字符类型：var a byte    字符用‘’

字符串表示两种方式： 1）“”双引号    2）``（反引号） 原生字符串

https://go-zh.org/pkg/     // 官网package

打印占位符
	General：
		%v	相应值的默认格式。在打印结构体时，“加号”标记（%+v）会添加字段名
		%T	相应值的类型的Go语法表示
	Integer
		%c  相应Unicode码点所表示的字符   Printf("%c", 0x4E2D)    中
		%q	单引号围绕的字符字面值，由Go语法安全地转义 Printf("%q", 0x4E2D)        '中'
		%b	二进制表示    Printf("%b", 5)    101
	浮点数和复数的组成部分（实部和虚部）
		%f	有小数点而无指数，例如 123.456        Printf("%f", 10.2)     10.200000
		%g	根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf("%g", 10.20)   10.2
	字符串与字节切片
		%x	十六进制，小写字母，每字节两个字符      Printf("%x", "golang")         676f6c616e67
	指针
		%p  十六进制表示，前缀 0x    Printf("%p", &people)    0x4f57f0
	
str := fmt.Sprintf("a=%d", a)

len()  // 时间复杂度O(1)，字符串的长度默认是存起来的，C是要找到‘\0’

浏览器敲网址到看到页面的全过程  讲师的理解  很细节



#############################
go day 3

fmt.Scanf("%d%d", &n, &m)    // 终端输入时默认空格分隔

strings和strconv使用
	strings.HasPrefix(s string, prefix string) bool             // 判断字符串s是否以prefix开头。
	strings.HasSuffix(s string, suffix string) bool             // 判断字符串s是否以suffix结尾。
	strings.Index(s string, str string) int                     // 判断str在s中首次出现的位置，如果没有出现，则返回-1
	strings.LastIndex(s string, str string) int                 // 判断str在s中最后出现的位置，如果没有出现，则返回-1
	strings.Replace(str string, old string, new string, n int)  // 字符串替换
	strings.Count(str string, substr string)int                 // 字符串计数
	strings.Repeat(str string, count int)string                 // 重复count次str
	strings.ToLower(str string)string                           // 转为小写
	strings.ToUpper(str string)string                           // 转为大写
	strings.TrimSpace(str string)                               // 去掉字符串首尾空白字符
	strings.Trim(str string, cut string)                        // 去掉字符串首尾cut字符
		strings.Trim("abbacba", "ab") // => "c"
	strings.TrimLeft(str string, cut string)                    // 去掉字符串首cut字符
	strings.TrimRight(str string, cut string)                   // 去掉字符串尾cut字符
	strings.Fields(str string)                                   // 返回str空格分隔的所有子串的slice
	strings.Split(str string, split string)                     // 返回str被split分隔的所有子串的slice
	strings.Join(s1 []string, sep string)                       // 用sep把s1中的所有元素链接起来
		fmt.Println(strings.Join([]string{"a", "b", "c"}, ","))  
		// => "a,b,c"
	strconv.Itoa(i int)                                         // 把一个整数i转成字符串   相对于下面，不存在error
	strconv.Atoi(str string)(int, error)                        // 把一个字符串转成整数  返回一个error 对象 

时间和日期类型
	time.Time类型，用来表示时间
	获取当前时间， now := time.Now()
	time.Now().Minute()，time.Now().Day()，time.Now().Month()，time.Now().Year()
	time。Now().UnixNano()     // 1970年1月1日UTC以来经过的纳秒数。  
	time.Duration用来表示纳秒 
	const (
		Nanosecond  Duration = 1
		Microsecond          = 1000 * Nanosecond
		Millisecond          = 1000 * Microsecond
		Second               = 1000 * Millisecond
		Minute               = 60 * Second
		Hour                 = 60 * Minute
	)
	格式化：
		now := time.Now()
		fmt.Println(now.Format(“02/1/2006 15:04”))
		fmt.Println(now.Format(“2006/1/02 15:04”))
		fmt.Println(now.Format(“2006/1/02”))

指针类型

流程控制
	如果switch没有表达式，它会匹配true。
	Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码，fallthrough不会判断下一条case的expr结果是否为true。

	for i := 0; i < 5; i++ {}    // 注意没有 ()
	
	goto 和 label 语句
		func main() {
		LABEL1:
			for i := 0; i <= 5; i++ {
				for j := 0; j <= 5; j++ {
					if j == 4 {
						continue LABEL1    // 或者 goto LABEL1
					}
					fmt.Printf("i is: %d, and j is: %d\n", i, j)
				}
			}
		}
	
go 中英文都是utf-8编码，英文占1个字节，中文占3个字节

函数
	不支持重载，一个包不能有两个名字一样的函数

	函数也是一种类型一个函数可以赋值给变量
	
	匿名函数
	
	多返回值
	
	值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。

	命名返回值的名字
		func calc(a, b int) (sum int, avg int) {
			sum = a + b
			avg = (a +b)/2
			return
		}

	_标识符，用来忽略返回值

	可变参数：
		func add(arg ...int) int {}  		  // 0个或多个参数

		func add(a int, arg ...int) int {}  // 1个或多个参数

		其中arg是一个slice，我们可以通过arg[index]依次访问所有参数，通过len(arg)来判断传递参数的个数

	defer
		1. 当函数返回时，执行defer语句。因此，可以用来做资源清理
		2. 多个defer语句，按先进后出的方式执行
		3. defer语句中的变量，在defer声明时就决定了。
			func a() {
				i := 0
				defer fmt.Println(i)    // 输出 0
				i++
				return
			} 
		用途
			1. 关闭文件句柄
				func read() {
					file := open(filename)
					defer file.Close()
					// 文件操作
				}
			2. 锁资源释放
				func read() {
					mc.Lock()
					defer mc.Unlock()
					// 其他操作
				}
			3. 数据库连接释放
				func read() {
					conn := openDatabase()
					defer conn.Close()
					// 其他操作
				}

				
			
############################
go day 4 

homework
	当字符串中有中英文时，rang str 返回的类型是int  int32，下标不一定是连续的
		str := "a2啊是"
		fmt.Println("len ", len(str))
		for i, v := range str {
			// fmt.Printf("%T-%T\n", i, v)   // int-int32
			fmt.Printf("%v  %c\n", i, v)
		}
			=>  len  8
				0  a
				1  2
				2  啊
				5  是
			
	rune数据类型   //int32的别名
		str := "a2啊是"
		t := []rune(str)             // 有中英文的字符串按照一个字符存4个字节，在utf-8中，中文3个字节，英文、数字一个字节
		fmt.Println(len(t))
		for i := 0; i < len(t); i++ {
			fmt.Printf("%d - %c - %x\n", i, t[i], t[i])
		}
			=>  4
				0 - a - 61
				1 - 2 - 32
				2 - 啊 - 554a
				3 - 是 - 662f

	bufio package
		reader := bufio.NewReader(os.Stdin)
		result, _, err  := reader.ReadLine()
		if err != nil {
			fmt.Println("read from console err:", err)
			return
		}

Outline
	1. 内置函数、递归函数、闭包
	2. 数组与切片
	3. map数据结构
	4. package介绍

内置函数
	1. close：主要用来关闭channel
	
	2. len：用来求长度，比如string、array、slice、map、channel
	
	3. new：用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针
	
	4. make：用来分配内存，主要用来分配引用类型，比如chan、map、slice
	
	5. append：用来追加元素到数组、slice中
		var a []int 
		a = append(a, 10)
		a = append(a, a...)  //   arg ...int 可变参数  这里表示将切片展开
		
	6. panic和recover：用来做错误处理
		func initConfig() (err error) {
			return errors.New("init config failed")
		}
		func test() {
			defer func() { 
				if err := recover(); err != nil {        // recover() 捕获异常,让程序继续运行，如果不捕获，有错误的话，整个程序就都挂了
					fmt.Println(err)      // 可以查一下，打印出当前的错误堆栈，会显示出错代码具体行数  
				}
			}()
			
			err := initConfig()
			if err != nil {
				panic(err)       // 主动抛出异常
			}
			return
		}

	7. new和make的区别
		new 返回的是指针，make 直接返回的是一个数据类型
	
递归函数
	
闭包：一个函数和与其相关的引用环境组合而成的实体
	func Adder() func(int) int {
        var x int
        return func(delta int) int {
			x += delta
			return x
        } 
	}
	func main() {
        var f = Adder()
        fmt.Print(f(1))   // => 1
        fmt.Print(f(20))  // => 21
        fmt.Print(f(300)) // => 321
	} 

数组与切片
	


	





































 

