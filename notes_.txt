#############################
go 老男孩教育Go语言第一期



#############################
why go

day 1
    go 静态编译，不需要在运行时判断变量的类型，强类型语言的优势

    编译要求{要跟在函数后面，不能另起一行，阅读方便

    存在未使用的变量或未使用的包，则编译不通过，减少冗余代码，降低代码维护成本

    内存自动回收，只需要new分配内存，不需要释放

    从语言层面支持并发，并发编程简单



#############################
day 1

搭建开发环境

vs插件安装
    https://www.jianshu.com/p/be432e57acd2

nginx  强调多进程的架构
redis  单进程单线程的架构    服务器就需要多起几个实例

go 静态编译，不需要在运行时判断变量的类型，强类型语言的优势

编译要求{要跟在函数后面，不能另起一行，阅读方便

存在未使用的变量或未使用的包，则编译不通过，减少冗余代码，降低代码维护成本

内存自动回收，只需要new分配内存，不需要释放

从语言层面支持并发，并发编程简单

其他语言要写一个高并发的服务，就必须以维护一个线程池，go不需要，go的线程更轻量化，且go自己维护一个线程池

go 的并发基于CSP（Communicating Sequential Process）模型实现
    CSP理解：多个goroute之间通过channel进行通信，每个goroute都是轻量级高性能的

命令行 gofmt -w file.go   规范化代码，解决缩进、空行什么的

go 可以一个函数返回多个值，c 不可以

包的概念
    1. 和python一样，把相同功能的代码放到一个目录，称之为包
    2. 包可以被其他包引用
    3. main包是用来生成可执行文件，每个程序只有一个main包
    4. 包的主要用途是提高代码的可复用性

go 的编码永远都是utf-8

环境变量GOPATH用于指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作区，可以在GOPATH中设置多个工作区

go 开发目录结构
    d:/project/src/go_dev/day1/example1/hello.go
              /bin/
              /vender/        // 第三方包
              /pkg/           // 静态库
    export GOPATH=d:/project/

构建 
    C:\Users\user\Desktop\go\project> go build -o bin/hello.exe dev/day1/hello
    go build 默认到src下面区找，所以go build 输入路径不用在前面加上src
    
go run file.go   类似执行一个脚本获取结果

 


#############################
go day 2 

go 编译，包名未main，有func main()，则编译生成可执程序，否则生成lib库

go 编译性语言，任何执行语句不能放在函数体之外，这是编译型语言和解释性语言的一个重要区别
    var name string
    name = "xxx"
    编译报错，需要写个函数，到函数里面去初始化

包别名
    import(
        a  "add"
    )
    import(
        _  "add"       //仅导入这个包，不引用里面的任何一个变量和函数，这么做可以通过编译
    )
 
每个源文件都可以包含一个init函数，这个init函数自动被go运行框架调用。

常量使用const 修饰，代表永远是只读的，不能修改。
    const 只能修饰boolean，number（int相关类型、浮点类型、complex）和string
    const identifier [type] = value，其中type可以省略。
        const a string = "xxx"
        const b = "xxx"    
        const c = 9/3 
        const (
            a string = "xxx"
            b = "xxx"    
            c = 9/3 
        )

var(
    a int      // 默认为0
    b string   // 默认为“”
    c bool     // 默认为false
    d = 8
    e = "hello"   // 没类型也行，默认做类型推导
)
        
值类型：基本数据类型int、float、bool、string以及数组和struct。 值类型的内存通常在栈中分配。
引用类型：指针、slice、map、chan等都是引用类型。  引用类型的内存通常在堆上分配。

栈，如执行到一条函数语句，则先用栈保存传入的参数，然后跳到函数的地址，然后再将参数出栈，go 的栈空间一般是几K
堆  物理内存，需要动态申请，用完要释放，多个线程共用，需要加锁，分配性能没有栈高

变量作用域 块作用域

数字类型，主要有int、int8、int16、int32、int64、uint8、uint16、uint32、uint64、float32、float64
    var a float   // 出错

字符类型：var a byte    字符用‘’

字符串表示两种方式： 1）“”双引号    2）``（反引号） 原生字符串

https://go-zh.org/pkg/     // 官网package

打印占位符
    General：
        %v    相应值的默认格式。在打印结构体时，“加号”标记（%+v）会添加字段名
        %T    相应值的类型的Go语法表示
    Integer
        %c  相应Unicode码点所表示的字符   Printf("%c", 0x4E2D)    中
        %q    单引号围绕的字符字面值，由Go语法安全地转义 Printf("%q", 0x4E2D)        '中'
        %b    二进制表示    Printf("%b", 5)    101
    浮点数和复数的组成部分（实部和虚部）
        %f    有小数点而无指数，例如 123.456        Printf("%f", 10.2)     10.200000
        %g    根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf("%g", 10.20)   10.2
    字符串与字节切片
        %x    十六进制，小写字母，每字节两个字符      Printf("%x", "golang")         676f6c616e67
    指针
        %p  十六进制表示，前缀 0x    Printf("%p", &people)    0x4f57f0
    
str := fmt.Sprintf("a=%d", a)

len()  // 时间复杂度O(1)，字符串的长度默认是存起来的，C是要找到‘\0’

浏览器敲网址到看到页面的全过程  讲师的理解  很细节



#############################
go day 3

fmt.Scanf("%d%d", &n, &m)    // 终端输入时默认空格分隔

strings和strconv使用
    strings.HasPrefix(s string, prefix string) bool             // 判断字符串s是否以prefix开头。
    strings.HasSuffix(s string, suffix string) bool             // 判断字符串s是否以suffix结尾。
    strings.Index(s string, str string) int                     // 判断str在s中首次出现的位置，如果没有出现，则返回-1
    strings.LastIndex(s string, str string) int                 // 判断str在s中最后出现的位置，如果没有出现，则返回-1
    strings.Replace(str string, old string, new string, n int)  // 字符串替换
    strings.Count(str string, substr string)int                 // 字符串计数
    strings.Repeat(str string, count int)string                 // 重复count次str
    strings.ToLower(str string)string                           // 转为小写
    strings.ToUpper(str string)string                           // 转为大写
    strings.TrimSpace(str string)                               // 去掉字符串首尾空白字符
    strings.Trim(str string, cut string)                        // 去掉字符串首尾cut字符
        strings.Trim("abbacba", "ab") // => "c"
    strings.TrimLeft(str string, cut string)                    // 去掉字符串首cut字符
    strings.TrimRight(str string, cut string)                   // 去掉字符串尾cut字符
    strings.Fields(str string)                                   // 返回str空格分隔的所有子串的slice
    strings.Split(str string, split string)                     // 返回str被split分隔的所有子串的slice
    strings.Join(s1 []string, sep string)                       // 用sep把s1中的所有元素链接起来
        fmt.Println(strings.Join([]string{"a", "b", "c"}, ","))  
        // => "a,b,c"
    strconv.Itoa(i int)                                         // 把一个整数i转成字符串   相对于下面，不存在error
    strconv.Atoi(str string)(int, error)                        // 把一个字符串转成整数  返回一个error 对象 

时间和日期类型
    time.Time类型，用来表示时间
    获取当前时间， now := time.Now()
    time.Now().Minute()，time.Now().Day()，time.Now().Month()，time.Now().Year()
    time。Now().UnixNano()     // 1970年1月1日UTC以来经过的纳秒数。  
    time.Duration用来表示纳秒 
    const (
        Nanosecond  Duration = 1
        Microsecond          = 1000 * Nanosecond
        Millisecond          = 1000 * Microsecond
        Second               = 1000 * Millisecond
        Minute               = 60 * Second
        Hour                 = 60 * Minute
    )
    格式化：
        now := time.Now()
        fmt.Println(now.Format(“02/1/2006 15:04”))
        fmt.Println(now.Format(“2006/1/02 15:04”))
        fmt.Println(now.Format(“2006/1/02”))

指针类型

流程控制
    如果switch没有表达式，它会匹配true。
    Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码，fallthrough不会判断下一条case的expr结果是否为true。

    for i := 0; i < 5; i++ {}    // 注意没有 ()
    
    goto 和 label 语句
        func main() {
        LABEL1:
            for i := 0; i <= 5; i++ {
                for j := 0; j <= 5; j++ {
                    if j == 4 {
                        continue LABEL1    // 或者 goto LABEL1
                    }
                    fmt.Printf("i is: %d, and j is: %d\n", i, j)
                }
            }
        }
    
go 中英文都是utf-8编码，英文占1个字节，中文占3个字节

函数
    不支持重载，一个包不能有两个名字一样的函数

    函数也是一种类型一个函数可以赋值给变量
    
    匿名函数
    
    多返回值
    
    值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。

    命名返回值的名字
        func calc(a, b int) (sum int, avg int) {
            sum = a + b
            avg = (a +b)/2
            return
        }

    _标识符，用来忽略返回值

    可变参数：
        func add(arg ...int) int {}            // 0个或多个参数

        func add(a int, arg ...int) int {}  // 1个或多个参数

        其中arg是一个slice，我们可以通过arg[index]依次访问所有参数，通过len(arg)来判断传递参数的个数

    defer
        1. 当函数返回时，执行defer语句。因此，可以用来做资源清理
        2. 多个defer语句，按先进后出的方式执行
        3. defer语句中的变量，在defer声明时就决定了。
            func a() {
                i := 0
                defer fmt.Println(i)    // 输出 0
                i++
                return
            } 
        用途
            1. 关闭文件句柄
                func read() {
                    file := open(filename)
                    defer file.Close()
                    // 文件操作
                }
            2. 锁资源释放
                func read() {
                    mc.Lock()
                    defer mc.Unlock()
                    // 其他操作
                }
            3. 数据库连接释放
                func read() {
                    conn := openDatabase()
                    defer conn.Close()
                    // 其他操作
                }

                
            
############################
go day 4 

homework
    当字符串中有中英文时，rang str 返回的类型是int  int32，下标不一定是连续的
        str := "a2啊是"
        fmt.Println("len ", len(str))
        for i, v := range str {
            // fmt.Printf("%T-%T\n", i, v)   // int-int32
            fmt.Printf("%v  %c\n", i, v)
        }
            =>  len  8
                0  a
                1  2
                2  啊
                5  是
            
    rune数据类型   //int32的别名
        str := "a2啊是"
        t := []rune(str)             // 有中英文的字符串按照一个字符存4个字节，在utf-8中，中文3个字节，英文、数字一个字节
        fmt.Println(len(t))
        for i := 0; i < len(t); i++ {
            fmt.Printf("%d - %c - %x\n", i, t[i], t[i])
        }
            =>  4
                0 - a - 61
                1 - 2 - 32
                2 - 啊 - 554a
                3 - 是 - 662f

    bufio package
        reader := bufio.NewReader(os.Stdin)
        result, _, err  := reader.ReadLine()
        if err != nil {
            fmt.Println("read from console err:", err)
            return
        }

Outline
    1. 内置函数、递归函数、闭包
    2. 数组与切片
    3. map数据结构
    4. package介绍

内置函数
    1. close：主要用来关闭channel
    
    2. len：用来求长度，比如string、array、slice、map、channel
    
    3. new：用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针
    
    4. make：用来分配内存，主要用来分配引用类型，比如chan、map、slice
    
    5. append：用来追加元素到数组、slice中
        var a []int 
        a = append(a, 10)
        a = append(a, a...)  //   arg ...int 可变参数  这里表示将切片展开
        
    6. panic和recover：用来做错误处理
        func initConfig() (err error) {
            return errors.New("init config failed")
        }
        func test() {
            defer func() { 
                if err := recover(); err != nil {        // recover() 捕获异常,让程序继续运行，如果不捕获，有错误的话，整个程序就都挂了
                    fmt.Println(err)      // 可以查一下，打印出当前的错误堆栈，会显示出错代码具体行数  
                }
            }()
            
            err := initConfig()
            if err != nil {
                panic(err)       // 主动抛出异常
            }
            return
        }

    7. new和make的区别
        new 返回的是指针，make 直接返回的是一个数据类型
    
递归函数
    
闭包：一个函数和与其相关的引用环境组合而成的实体
    func Adder() func(int) int {
        var x int
        return func(delta int) int {
            x += delta
            return x
        } 
    }
    func main() {
        var f = Adder()
        fmt.Print(f(1))   // => 1
        fmt.Print(f(20))  // => 21
        fmt.Print(f(300)) // => 321
    } 

数组
    数组：是同一种数据类型的固定长度的序列。
    
    长度是数组类型的一部分，因此，var a[5] int和var a[10]int是不同的类型

    数组是值类型，因此改变副本的值，不会改变本身的值
        var arr1 [5]int
        arr2 := arr1
        arr2[2] = 100    // arr1 不会改变

    数组是定长的   切片是不定长的
    
    1. 数组初始化
        a. var age0 [5]int = [5]int{1,2,3}       // 后面的默认为0
        b. var age1 = [5]int{1,2,3,4,5}          // 自动类型推导
        c. var age2 = [...]int{1,2,3,4,5,6}      // ... 的第三个作用：自动数有几个元素
        d. var str = [5]string{3:”hello world”, 4:”tom”}         // 还可以指定下标初始化
    
    2. 多维数组
        a. var age [5][3]int
        b. var f [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}}

切片
    切片：切片是数组的一个引用，因此切片是引用类型
    
    切片的长度可以改变，因此，切片是一个可变的数组
    
    切片遍历方式和数组一样，可以用len()求长度
    
    cap可以求出slice最大的容量，0 <= len(slice) <= cap(array)，其中array是slice引用的数组    
    
    切片的定义：var 变量名 []类型，比如 var str []string  var arr []int

    通过make来创建切片  也可以通过已经定义的数组来创建
        var slice []type = make([]type, len)
        slice  := make([]type, len)
        slice  := make([]type, len, cap)       // 在不声明 cap 的情况下，默认 cap=len
        slice := []int{1, 2, 3, 4, 5}          // 这种方式，len是根据初始化长度而定的
        
    当对切片进行 append 操作，导致长度超出容量时，就会创建新的数组，这会导致和原有切片的分离。

    拷贝
        var a []int = []int{1, 2, 3, 4, 5, 6}
        b := make([]int, 1)
        copy(b, a)
        fmt.Println(b)    //   => [1]  没有报错，拷贝不会像append 一样去扩容
    
    string与slice
        string底层就是一个byte的数组，因此，也可以进行切片操作

    如何改变string中的字符值？string本身是不可变的，因此要改变string中字符，需要如下操作：
        str := “hello world 中国”
        s := []rune(str)    //  s := []byte(str) 处理中文有问题
        s[0] = ‘o’
        str = string(s)

数组与切片的排序    sort   package 
    sort.Ints   sort.Strings  sort.Float64  

    sort.SearchInts(a []int, b int)               //从切片a中查找b，默认返回的是从小到大排序后再查找的下标
    sort.SearchFloats(a []float64, b float64)    
    sort.SearchStrings(a []string, b string)      

map    key-value的数据结构，又叫字典或关联数组
    声明
        var map1 map[keytype]valuetype      //  声明是不会分配内存的，初始化需要make
        
        a := make(map[string]map[string]string, 100)
        a["key1"] = make(map[string]string)       // make 只能初始化第一层，第二层不初始化下面的赋值会panic
        a["key1"]["key2"] = "abc"
    
    map相关操作
        初始化
            var a map[string]string = map[string]string{“hello”: “world”}  
            a = make(map[string]string, 10)      // 超出容量时会自动扩容，但尽量提供一个合理的初始值
            cap(a)    // cap: 返回的是数组切片分配的空间大小, 根本不能用于map
            
        插入和更新
            a[“hello”] = “world”

        查找
            val, ok := a[“hello”]
        
        遍历
            for k, v := range a {
                fmt.Println(k,v)
            }
        
        删除
            delete(a, “hello”)   //  删除整个map 可以for循环，也可以重新 make 一个

        长度
            len(a)

        用map 和slice 之前一定要判断又没有初始化，没有初始化就用会panic

        map排序    map 默认是无序的，原因之一：开发者认为，如果是有序的，线上的程序依赖这个排序来处理业务逻辑，假如有一天go 的代码有问题，则整个业务都崩了，解耦合，想要有序，自己再处理
            先获取所有key，把key进行排序，然后按照排序好的key，进行遍历
                var a map[int]int
                a = make(map[int]int, 5)
                var keys []int
                for k, _ := range a {
                    keys = append(keys, k)
                }
                sort.Ints(keys)
                for _, v := range keys {
                    fmt.Println(v, a[v])
                }
        
        map反转
            初始化另外一个map，把key、value互换即可

package 
    
线程同步
    import(“sync”)
        var mu sync.Mutex     // 互斥锁, 无论是读还是写协程，同时只能有一个协程在操作
        mu.Lock()
        mu.Unlock()
        
        var mu sync.RWMutex   // 读写锁, 读锁的时候，可以有多个读的协程在操作    读多写少的情况下使用，性能高
        mu.Lock()    // 写锁操作
        mu.Unlock()
        mu.RLock()   // 读锁操作
        mu.RUnlock()
    
    go build -race    // 编译的时候检查是否有用锁出错的地方, 写并发的时候要检查哪里还没有加锁

原子操作    
    atomic.AddInt32(&count, 1)    // 使多个协程对count处理时逻辑上正确，count 加1时是串行的
    atomic.LoadInt32(&count)
    
go get安装第三方包



############################
go day 5

Outline
    1. 结构体和方法
    2. 接口
    3. 课后作业

Go中的struct
    1. 用来自定义复杂数据结构
    2. struct里面可以包含多个字段（属性）
    3. struct类型可以定义方法，注意和函数的区分
    4. struct类型是值类型
    5. struct类型可以嵌套
    6. Go语言没有class类型，只有struct类型    // 和其他语言的重要区别

    声明
        type 标识符 struct {
               field1 type
               field2 type
        }

    struct 中字段访问：和其他语言一样，使用.

    struct定义的三种形式：
        var stu Student
        var stu *Student = new (Student)
        var stu *Student = &Student{}

    访问形式   
        stu.Name         // stu 是指针类型也行，go 会自动转成(*stu).Name
        (*stu).Name

    struct的内存布局：struct中的所有字段在内存是连续的
        type Student struct {
            Name  string
            Age   int
            score float32
        }
        
        stu.Name = "hua"
        stu.Age = 18
        stu.score = 80

        fmt.Printf("Name:%p\n", &stu.Name)
        fmt.Printf("Age: %p\n", &stu.Age)
        fmt.Printf("score:%p\n", &stu.score)
            
        =>  
        Name:0xc000004480
        Age: 0xc000004490           // “hua” 占用 10 字节？ 
        score:0xc000004498          // int 占用 8 字节     利用“struct中的所有字段在内存是连续的”来计算int占用的字节数

    链表定义
        type Student struct {
               Name string
               Next* Student
        }

    双链表定义
        type Student struct {
               Name string
               Next* Student
               Prev* Student
        }

    二叉树定义
        type Student struct {
               Name string
               left* Student
               right* Student
        }

    别名
        type Student struct {
            Number int
        }
        type Stu Student   
        var a Student, b stu    
        a = b    //  不能赋值，虽然有相同的字段，但是属于不同的类型
        
    golang中的struct没有构造函数，一般可以使用工厂模式来解决这个问题     ？工厂模式

    make 用来创建map、slice、channel    new用来创建值类型

    我们可以为struct中的每个字段，写上一个tag。这个tag可以通过反射的机制获取到，最常用的场景就是json序列化和反序列化     ？后面讲
        type Student struct {
            Name  string `json:"student_name"`
            Age   int    `json:"age"`
            Score int    `json:"score"`
        }

    
    匿名字段    结构体中字段可以没有名字
        type Car struct {
            Name stirng
            Age int        
        }
        type Train struct {
            Car
            Start time.Time
            int
        }

    方法
        Golang中的方法是作用在特定类型的变量上，因此自定义类型，都可以有方法，而不仅仅是struct
        
        定义：func (recevier type) methodName(参数列表)(返回值列表){}

        方法和函数的调用区别
            函数：function(variable, 参数列表）
            方法：variable.function(参数列表）

        方法的访问控制，通过大小写控制

        调用方法时，
            type integer int
            func (p *integer) set(b integer) {
                *p = b
            }
            var a integer
            a = 100
            a.set(1000)    //  不用写成(*a).set(1000)  go 会自动转化
    
    继承   组合
        如果一个struct嵌套了另一个匿名结构体，那么这个结构可以直接访问匿名结构体的方法，从而实现了继承。
    
        如果一个struct嵌套了另一个有名结构体，那么这个模式就叫组合。

        多重继承
            如果一个struct嵌套了多个匿名结构体，那么这个结构可以直接访问多个匿名结构体的方法，从而实现了多重继承。

接口
    Interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。

    定义
        type example interface{
            Method1(参数列表) 返回值列表
            Method2(参数列表) 返回值列表
            …
        }

    interface类型默认是一个指针

    接口实现
        Golang中的接口，不需要显示的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。

    多态
        一个接口，多种实现

    接口嵌套
        type ReadWrite interface {
            Read(b Buffer) bool
            Write(b Buffer) bool
        } 
        type Lock interface {
            Lock()
            Unlock() 
        } 
        type File interface {
            ReadWrite
            Lock 
            Close() 
        } 
    


############################
go day 6

go 里面的结构体可以认为是其他语言的类

Outline
    1. 接口
    2. 反射

为什么要用接口
    忽略低层实现，比如当前的的模块的数据是用mysql存，当变成用oreacal后，接口不变，依然不影响模块之间的调用
    
所有的类型都可以给空接口赋值，用一个变量来存任何类型的数据的时候，可以用一个空接口的变量
    type Test interface {
    }
    
    var a interface{}
    var b int 
    a = b
    
    变量slice和接口slice之间赋值操作，用for range
        var a []int
        var b []interface{}
        b = a   // 报错  用for range才行  ？



任何类型，只要实现了接口的所有方法，也就是实现了这个接口，然后就能调用Sort()来排序。  用接口，让函数的可扩展性很好
    func Sort(data Interface)

    type Interface interface {
        // Len方法返回集合中的元素个数
        Len() int
        // Less方法报告索引i的元素是否比索引j的元素小
        Less(i, j int) bool
        // Swap方法交换索引i和j的两个元素
        Swap(i, j int)
    }

类型断言
    由于接口是一般类型，不知道具体类型，如果要转成具体类型可以采用以下方法进行转换：
        var t int
        var x interface{}
        x = t
        y = x.(int)       // 转成int
        y, ok = x.(int)   // 转成int，带检查

写一个函数判断传入参数的类型
    func classifier(items ...interface{}) {
          for i, x := range items { 
                  switch x.(type) {     // type 是关键字
                   case bool:       fmt.Printf(“param #%d is a bool\n”, i)
                   case float64:    fmt.Printf(“param #%d is a float64\n”, i)
                   case int, int64: fmt.Printf(“param #%d is an int\n”, i)
                   case nil: fmt.Printf(“param #%d is nil\n”, i)
                   case string: fmt.Printf(“param #%d is a string\n”, i)
                   default: fmt.Printf(“param #%d’s type is unknown\n”, i)
            }
    }

判断一个变量是否实现了指定的接口
    var f *File
	var b interface{}
	b = f
	v, ok := b.(ReadWriter)    // ReadWriter是一个接口类型
	fmt.Println(v, ok)

反射：可以在运行时动态获取变量的相关信息
    import (“reflect”)

    两个函数
        a. reflect.TypeOf()，获取变量的类型，返回reflect.Type类型     // 和reflect.Value.Kind返回的有区别
        
        b. reflect.ValueOf，获取变量的值，返回reflect.Value类型
            reflect.Value.Kind，获取变量的类别，返回一个常量   如：reflect.Struct
        
            reflect.Value.Interface()，转换成interface{}类型
            
            获取变量的值
                reflect.ValueOf(x).Float() 
                reflect.ValueOf(x).Int()
                reflect.ValueOf(x).String()
                reflect.ValueOf(x).Bool()

            通过反射的来改变变量的值
                reflect.Value.SetFloat()，设置浮点数
                reflect.Value.SetInt()，设置整数
                reflect.Value.SetString()，设置字符串

            当reflect.Value类型的reflect.Value.Kind是Ptr的时候
                var a float64
                fv := reflect.ValueOf(a)    
                fv.SetFloat(3.3)      // panic 因为传入reflect.ValueOf()的a是一个值类型，在副本中设置值不起作用，go就直接panic了，要传指针进去
              
                func (v Value) Elem() Value  // Elem返回v持有的接口保管的值的Value封装，或者v持有的指针指向的值的Value封装。如果v的Kind不是Interface或Ptr会panic；如果v持有的值为nil，会返回Value零值。
                    	val := reflect.ValueOf(b)    // var b interface{}
                        val.Elem().SetInt(100)
             
            用反射操作结构体
                reflect.Value.NumField()获取结构体中字段的个数
                reflect.Value.Method(n).Call来调用结构体中的方 法

                
    变量 --实现接口的所有方法-> interface -- reflect.ValueOf -> reflect.Type类型
    变量 <-断言-- interface <- reflect.Value.Interface -- reflect.Type类型
    
只有结构体或者接口才有方法



############################
go day 7

int64转int变成负数  ？？
  
Outline
    1. 终端读写
    2. 文件读写
    3. 课后作业

终端读写
    操作终端相关文件句柄常量
        os.Stdin：标准输入
        os.Stdout：标准输出
        os.Stderr：标准错误输出

带缓冲区的读写
    inputReader = bufio.NewReader(os.Stdin)
	fmt.Println("Please enter some input: ")
	input, err = inputReader.ReadString('\n')
	if err == nil {
		fmt.Printf("The input was: %s\n", input)
	}

文件读写
    os.File封装所有文件相关操作，是一个结构体，之前讲的 os.Stdin,os.Stdout, os.Stderr都是*os.File
    
    打开一个文件进行读操作： os.Open(name string) (*File, error)
          
    关闭一个文件：File.Close()    // 因为操作系统对打开的文件句柄总数有一个上限
    
读取整个文件
       buf, err != ioutil.ReadFile(inputFile)
       
读取压缩文件
	fz, err := gzip.NewReader()

文件写入
    os.OpenFile(“output.dat”,  os.O_WRONLY|os.O_CREATE, 0666)
        第二个参数：文件打开模式
            os.O_WRONLY：只写
            os.O_CREATE：创建文件
            os.O_RDONLY：只读
            os.O_RDWR：读写
            os.O_TRUNC ：清空
            
        第三个参数：权限控制：
            r ——> 004
            w——> 002
            x——> 001
拷贝文件
    io.Copy()
    
命令行参数
    os.Args是一个string的切片，用来存储所有的命令行参数

    flag包的使用，用来解析命令行参数：
        flag.BoolVar(&test, "b", false, "print on newline")
        flag.StringVar(&str, "s", "", "print on newline")
        flag.IntVar(&count, "c", 1001, "print on newline")
        flage.Parse()

Json数据协议
    导入包：Import “encoding/json”
    
    序列化: json.Marshal(data interface{})
        var m map[string]interface{}
        err = json.Unmarshal([]byte(data), &m)    // 要修改map中的值  所以要传地址

    反序列化: json.UnMarshal(data []byte,  v interface{})

错误处理
    error 是接口类型
        
    自定义错误

    Panic&Recover



############################
go day 8

Outline 
    goroutine
    channel
    单元测试
    
其他语言要处理并发，就必须要实现线程池，和线程之间的数据共享

进程和线程的区别
    进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位
    
    线程是进程的一个执行实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位
    
    一个进程可以创建和撤销多个线程；同一个进程中的多个线程之间可以并发执行
    
程序类型
    单线程程序、多线程程序、多进程程序(例如 nginx)  
    
并发和并行
    并发：多线程程序在一个核的cpu上运行
    并行：多线程程序在多个核的cpu上运行
    
协程和线程
    协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的
    
    线程：一个线程上可以跑多个协程，协程是轻量级的线程
    
goroutine调度模型
    M: 线程
    P: 上下文
    G: 协程

go 1.8 之前，默认只用一个核，需要设置go运行的cpu核数   1.8以上的默认使用所有的核
    num := runtime.NumCPU()
    runtime.GOMAXROCS(num)
    
goroutine之间的通信
    a. 全局变量和锁同步
    b. channel
    
channel
    类似unix中的管道(pipe)
    先进先出
    线程安全，多个goroutine同时访问，不需要加锁
    channel是有类型的，一个整数的channel只能存放整数

    声明
        var 变量名 chan 类型    // 可读可写
        只读的chan  var 变量名 <-chan 类型
        只写的chan  var 变量名 chan<- 类型
        
        双向channel可以赋值给单项channel,反过来则不行
        
    chan 读取
        var testChan chan int 
        testChan = make(chan int, 10)
        var a int 
        a = <- testChan    // a, ok := <- testChan  当把管道关了，能取出剩余的数据，去完后再取，则ok == false，取出的值都是int的默认值; 如果管道没有关 close(testChan), 取完后再取，则会阻塞
    
    chan 写入
        var testChan chan int
        testChan = make(chan int, 10)
        var a int = 10
        testChan <- a

    chan 遍历
        var ch chan int
        ch = make(chan int, 1000)

        for i := 0; i < 1000; i++ {
            ch <- i
        }

        close(ch)             
        for v := range ch {
            fmt.Println(v)        // 如果管道关了，读完所有数据后退出for  range循环，如果没关管道，则会阻塞
        }
        
        或者
            for {
                v, ok := <-ch
                if !ok {           //  // 判断ok == false时，则退出遍历循环
                    break 
                }
                fmt.Println(v)
            }
    
    chan 之间的同步
        子协程退出的时候用chan给主协程发信号
    
        <- testChan  // 只取出数据，并不使用赋值
        
    chan进行select操作      // 从chan 取数据就不会堵塞了
        var ch chan int
        ch = make(chan int, 10)
        ch2 := make(chan int, 10)
        go func() {
            var i int
            for {
                ch <- i
                time.Sleep(time.Second)
                ch2 <- i * i
                time.Sleep(time.Second)
                i++
            }
        }()
        for {
            select {
            case v := <-ch:
                fmt.Println(v)
            case v := <-ch2:
                fmt.Println(v)
            case <-time.After(time.Second):
                fmt.Println("get data timeout")
                time.Sleep(time.Second)
            }
        }
            
    select就是用来监听和channel有关的IO操作
        select {
        case <- chan1:     // 如果chan1成功读到数据，则进行该case处理语句， 忽略读到的值
        default: 
        }       
    
        遇到写或者读channel会出现堵塞的情况，可以用select, 如果不能读或不能写，则走default, 让程序不堵塞
    
    判断chan 是否关闭
        for {
            v, ok := <-ch      
            if !ok {           // 从ch 中读数据，如果ok==false则说明数据已经读完，并且ch已关闭
                break
            }
            fmt.Println(v)
        }
        
        用close(ch)关闭channel之后，for range 遍历channel中已存在的元素，遍历完之后for range 自动结束循环 
 
在main中向chan写入大于容量的数据，死锁    解决：开一个协程来做
	intChan := make(chan int, 1000)

	for i := 0; i < 1001; i++ {
		intChan <- i
	}
    // 解决
	intChan := make(chan int, 1000)
	go func() {
		for i := 0; i < 10000; i++ {
			intChan <- i
		}
	}()

在main中读chan，如果读一个空的chan，死锁     解决：开一个协程来做
	exitChan := make(chan bool, 8)
	for i := 0; i < 7; i++ {
		exitChan <- true
	}
	for i := 0; i < 8; i++ {
		<-exitChan
	}
	// 解决
	exitChan := make(chan bool, 8)
	for i := 0; i < 7; i++ {
		exitChan <- true
	}
	go func() {
		for i := 0; i < 8; i++ {
			<-exitChan
		}
	}()
 
定时器的使用
    t = time.NewTicker(time.Second)   
    for v := range t.C {              // C是chan
        fmt.Println("hello", v)
    }
     
一次性定时器
    select {
    case <- time.After(time.Second):    // 忽略管道拿出来的值   文档不推荐这么用，可能有内存泄漏的问题  ？？
        fmt.Println("after")    
    }

超时控制
    定时器用完一定要回收，否则有内存泄露的风险
        for {
            t := time.NewTicker(time.Second)
            select {
            case <-t.C:
                fmt.Println("timeout")
            }
            t.Stop()
		}

goroutine中使用recover
    如果一个goroutine panic, 则整个进程都挂了，所以要捕获panic, 让一个goroutine挂了之后不会影响其他的goroutine, 
        defer func() {
            if err := recover(); err != nil {
                fmt.Println("panic:", err)
            }
        }()

单元测试
    文件名必须以_test.go结尾
    
    在xxx_test.go中，测试用例的函数必须以Test开头，函数的参数固定：t *testing.T
        func TestAdd(t *testing.T) {
            r := add(2, 4)
            if r != 6 {
                t.Fatalf("add(2, 4) error, expect:%d, actual:%d", 6, r)   // 退出当前运行的程序，并输出信息
            }
            t.Logf("test add succ")   // go test -v 时输出日志
        }
        
    在单元测试文件的目录下，命令行执行 go test -v    



############################
go day 9

Outline
    1. Tcp编程
    2. redis使用

tcp服务端处理连接的3种模式
    1. 阻塞的。   来一个连接处理一个，处理完再执行下一个连接
    2. 接收一个线程之后，创建一个线程来处理连接，不堵塞，但是操作系统创建的线程数有上限，例如早期的apache
    3. epoll, 来一个连接，把它扔到epoll监听的事件里面，变成异步的，当事件有数据可读，epoll会通知你处理，然后你再处理这个事件。例如Nginx

1024以下的端口都是预先分配好的，规范好的，不能用，业务要用就用8000以上的端口，避免冲突

socket编程
    服务端的处理流程
        a. 监听端口
        b. 接收客户端的链接
        c. 创建goroutine，处理该链接
        
        func main() {
            fmt.Println("start server ...")
            listen, err := net.Listen("tcp", "0.0.0.0:50000")
            if err != nil {
                fmt.Println("listen failed, err:", err)
                return
            }
            for {
                conn, err := listen.Accept()
                if err != nil {
                    fmt.Println("accept failed, err:", err)
                    continue
                }
                go process(conn)
            }
        }

        func process(conn net.Conn) {
            defer conn.Close()
            for {
                buf := make([]byte, 512)
                n, err := conn.Read(buf)
                if err != nil {
                    fmt.Println("read err:", err)
                    return
                }

                fmt.Printf(string(buf[0:n]))
            }
        }

        
    客户端的处理流程
        a. 建立与服务端的链接
        b. 进行数据收发
        c. 关闭链接

        func main() {
            conn, err := net.Dial("tcp", "localhost:50000")
            if err != nil {
                fmt.Println("Error dialing", err.Error())
                return
            }

            defer conn.Close()
            inputReader := bufio.NewReader(os.Stdin)
            for {
                input, _ := inputReader.ReadString('\n')
                trimmedInput := strings.Trim(input, "\r\n")
                if trimmedInput == "Q" {
                    return
                }
                _, err = conn.Write([]byte(trimmedInput))
                if err != nil {
                    return
                }
            }

        }

    发送http请求
        conn, err := net.Dial("tcp", "www.baidu.com:80")
        if err != nil {
            fmt.Println("Error dialing", err.Error())
            return
        }

        defer conn.Close()

        msg := "GET / HTTP/1.1\r\n"
        msg += "Host:www.baidu.com\r\n"
        msg += "Connection:keep-alive\r\n"
        //msg += "User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\r\n"
        msg += "\r\n\r\n"

        n, err := io.WriteString(conn, msg)
        if err != nil {
            fmt.Println("write string failed")
        }

        fmt.Println("send to baidu.com bytes: ", n)
        buf := make([]byte, 4096)
        for {
            count, err := conn.Read(buf)
            fmt.Println("count: ", count, "err:", err)
            if err != nil {
                break
            }
            fmt.Println(string(buf[:count]))
        }

redis
    是个开源的高性能的key-value的内存数据库，可以把它当成远程的数据结构。

    使用第三方开源的redis库
        github.com/garyburd/redigo/redis

        go get github.com/garyburd/redigo/redis
        
    import (
        “github.com/garyburd/redigo/redis"
    ) 

    链接redis   Set 接口   Hash表   批量Set   过期时间    队列操作
        ???
    
聊天系统
    ???



############################
go day 10

Outline
    http编程
    mysql使用

http编程
    Go原生支持http，import(“net/http”)
    
    Go的http服务性能和nginx比较接近
        go开发的web程序上线之后，逻辑上前面不需要加Nginx

    几行代码就可以实现一个web服务
        package main

        import (
            "fmt"
            "net/http"
        )

        func Hello(w http.ResponseWriter, r *http.Request) {
            fmt.Println("handle hello")
            fmt.Fprintf(w, "hello ")
        }

        func main() {
            http.HandleFunc("/", Hello)
            err := http.ListenAndServe("0.0.0.0:8880", nil)
            if err != nil {
                fmt.Println("http listen failed")
            }
        }

    http client编程
        package main

        import (
            "fmt"
            "io/ioutil"
            "net/http"
        )

        func main() {
            res, err := http.Get("https://www.baidu.com/")
            if err != nil {
                fmt.Println("get err:", err)
                return
            }

            data, err := ioutil.ReadAll(res.Body)
            if err != nil {
                fmt.Println("get data err:", err)
                return
            }

            fmt.Println(string(data))
        }

    http常见请求方法
        1）Get请求
            Nginx Get请求url的长度不超过8k
        2）Post请求
            提交数据的大小不受限制
        3）Put请求
            创建一个资源
        4）Delete请求
            删除一个资源
        5）Head请求
            var url = []string{
                "http://www.baidu.com",
                "http://google.com",
                "http://taobao.com",
            }
            func main() {
                for _, v := range url {
                    // 自己实现一个请求客户端，使得所有连接的超时时间为2秒
                    c := http.Client{       
                        Transport: &http.Transport {
                            Dial:func(network, addr string) (net.Conn, error){
                                timeout := time.Second*2
                                return net.DialTimeout(network, addr, timeout)
                            },
                        },
                    }
                    resp, err := c.Head(v)
                    if err != nil {
                        fmt.Printf("head %s failed, err:%v\n", v, err)
                        continue
                    }

                    fmt.Printf("head succ, status:%v\n", resp.Status)
                }
            }
    
    http常见的状态码
        0
    
    表单处理
        const form = `<html><body><form action="#" method="post" name="bar">
                    <input type="text" name="in"/>
                    <input type="text" name="in"/>
                     <input type="submit" value="Submit"/>
             </form></body></html>`

        func SimpleServer(w http.ResponseWriter, request *http.Request) {
            io.WriteString(w, "hello, world")
            panic("test test")
        }

        func FormServer(w http.ResponseWriter, request *http.Request) {
            w.Header().Set("Content-Type", "text/html")
            switch request.Method {
            case "GET":
                io.WriteString(w, form)
            case "POST":
                request.ParseForm()
                io.WriteString(w, request.Form["in"][1])
                io.WriteString(w, "\n")
                io.WriteString(w, request.FormValue("in"))
            }
        }
        func main() {
            http.HandleFunc("/test1", logPanics(SimpleServer))
            http.HandleFunc("/test2", logPanics(FormServer))
            if err := http.ListenAndServe(":8088", nil); err != nil {
            }
        }
 
        func logPanics(handle http.HandlerFunc) http.HandlerFunc {    // panic处理
            return func(writer http.ResponseWriter, request *http.Request) {
                defer func() {
                    if x := recover(); x != nil {
                        log.Printf("[%v] caught panic: %v", request.RemoteAddr, x)
                    }
                }()
                handle(writer, request)
            }
        }
            
    panic处理  
        如上注释处
        
    模板
        1）替换 {{.字段名}}
        2）if判断
        3）range循环

        var myTemplate *template.Template

        type Result struct {
            output string
        }

        func (p *Result) Write(b []byte) (n int, err error) {
            fmt.Println("called by template")
            p.output += string(b)
            return len(b), nil
        }

        type Person struct {
            Name  string
            Title string
            Age   int
        }

        func userInfo(w http.ResponseWriter, r *http.Request) {
            fmt.Println("handle hello")
            //fmt.Fprintf(w, "hello ")
            var arr []Person
            p := Person{Name: "Mary001", Age: 10, Title: "我的个人网站"}
            p1 := Person{Name: "Mary002", Age: 10, Title: "我的个人网站"}
            p2 := Person{Name: "Mary003", Age: 10, Title: "我的个人网站"}
            arr = append(arr, p)
            arr = append(arr, p1)
            arr = append(arr, p2)

            resultWriter := &Result{}
            io.WriteString(resultWriter, "hello world")
            err := myTemplate.Execute(w, arr)
            if err != nil {
                fmt.Println(err)
            }
            fmt.Println("template render data:", resultWriter.output)
            //myTemplate.Execute(w, p)
            //myTemplate.Execute(os.Stdout, p)
            //file, err := os.OpenFile("C:/test.log", os.O_CREATE|os.O_WRONLY, 0755)
            //if err != nil {
            //	fmt.Println("open failed err:", err)
            //	return
            //}

        }

        func initTemplate(filename string) (err error) {
            myTemplate, err = template.ParseFiles(filename)
            if err != nil {
                fmt.Println("parse file err:", err)
                return
            }
            return
        }

        func main() {
            initTemplate("d:/project/src/go_dev/day10/template_http/index.html")
            http.HandleFunc("/user/info", userInfo)
            err := http.ListenAndServe("0.0.0.0:8880", nil)
            if err != nil {
                fmt.Println("http listen failed")
            }
        }

mysql编程
    增删改查  ？
    
聊天室 0



############################
go day 11

日志收集系统
    项目背景
        a. 每个系统都有日志，当系统出现问题时，需要通过日志解决问题
        b. 当系统机器比较少时，登陆到服务器上查看即可满足 
        c. 当系统机器规模巨大，登陆到机器上查看几乎不现实
    
    解决方案
        a. 把机器上的日志实时收集，统一的存储到中心系统
        b. 然后再对这些日志建立索引，通过搜索即可以找到对应日志
        c. 通过提供界面友好的web界面，通过web即可以完成日志搜索

    面临的问题
        a. 实时日志量非常大，每天几十亿条
        b. 日志准实时收集，延迟控制在分钟级别
        c. 能够水平可扩展

    业界方案elk的问题
        a. 运维成本高，每增加一个日志收集，都需要手动修改配置
        b. 监控缺失，无法准确获取logstash的状态
        c. 无法做定制化开发以及维护

    系统各组件介绍
        a. Log Agent，日志收集客户端，用来收集服务器上的日志
        b. Kafka，高吞吐量的分布式队列，linkin开发，apache顶级开源项目
        c. ES，elasticsearch，开源的搜索引擎，提供基于http restful的web接口
        d. Hadoop，分布式计算框架，能够对大量数据进行分布式处理的平台

    kafka应用场景
        1. 异步处理, 把非关键流程异步化，提高系统的响应时间和健壮性
            如用户注册写入数据库(50ms)然后发邮件通知用户(50ms), 用kafka就可以将发邮件的事件发送丢给消息队列(5ms), 启一个goroutine去处理，这样系统可以在55ms返回响应，提高系统的响应时间，如果发送邮件失败，还可以重复从kafka中读数据再发送，提高健壮性
            
        2. 应用解耦,通过消息队列，
            生产者不需要关注不同的消费者的接口，只需要把数据丢到消息队列中，不同的消费者根据自己的需要去取
            
        3. 流量削峰
            抢购的时候，流量大，用消息队列来模拟排队逻辑

    zookeeper应用场景
        1. 服务注册&服务发现
            微服务
        
        2. 配置中心
            不同的业务从zk读取自己自己业务变化的配置，然后更新，通过一个web平台管理zk, 这就不需要去单独更新各个业务的不同配置，
    
        3. 分布式锁
            - Zookeeper是强一致的
            - 多个客户端同时在Zookeeper上创建相同znode，只有一个创建成功
    
    安装kafka
        
    kafka写入实例代码
        package main

        import (
            "fmt"
            "github.com/Shopify/sarama"
        )

        func main() {
            config := sarama.NewConfig()
            config.Producer.RequiredAcks = sarama.WaitForAll
            config.Producer.Partitioner = sarama.NewRandomPartitioner
            config.Producer.Return.Successes = true

            msg := &sarama.ProducerMessage{}
            msg.Topic = "nginx_log"
            msg.Value = sarama.StringEncoder("this is a good test, my message is good")

            client, err := sarama.NewSyncProducer([]string{"192.168.31.177:9092"}, config)
            if err != nil {
                fmt.Println("producer close, err:", err)
                return
            }

            defer client.Close()

            pid, offset, err := client.SendMessage(msg)
            if err != nil {
                fmt.Println("send message failed,", err)
                return
            }

            fmt.Printf("pid:%v offset:%v\n", pid, offset)
        }

    tailf组件使用
        package main

        import (
            "fmt"
            "github.com/hpcloud/tail"
            "time"
        )
        func main() {
            filename := "./my.log"
            tails, err := tail.TailFile(filename, tail.Config{
                ReOpen:    true,
                Follow:    true,
                Location:  &tail.SeekInfo{Offset: 0, Whence: 2},
                MustExist: false,
                Poll:      true,
            })
            if err != nil {
                fmt.Println("tail file err:", err)
                return
            }
            var msg *tail.Line
            var ok bool
            for true {
                msg, ok = <-tails.Lines
                if !ok {
                    fmt.Printf("tail file close reopen, filename:%s\n", tails.Filename)
                    time.Sleep(100 * time.Millisecond)
                    continue
                }
                fmt.Println("msg:", msg)
            }
        }

    配置文件库使用
        Import “github.com/astaxie/beego/config”

        初始化配置库
            iniconf, err := NewConfig("ini", "testini.conf")
            if err != nil {
                t.Fatal(err)
            }

        读取配置项
            String(key string) string
            Int(key string) (int, error)
            Int64(key string) (int64, error)
            Bool(key string) (bool, error)
            Float(key string) (float64, error)

        package main

        import (
            "fmt"
            "github.com/astaxie/beego/config"
        )

        func main() {
            conf, err := config.NewConfig("ini", "./logcollect.conf")
            if err != nil {
                fmt.Println("new config failed, err:", err)
                return
            }

            port, err := conf.Int("server::port")
            if err != nil {
                fmt.Println("read server:port failed, err:", err)
                return
            }

            fmt.Println("Port:", port)
            log_level, err := conf.Int("log::log_level")
            if err != nil {
                fmt.Println("read log_level failed, ", err)
                return
            }
            fmt.Println("log_level:", log_level)

            log_path := conf.String("log::log_path")
            fmt.Println("log_path:", log_path)
        }

    日志库的使用
        Import “github.com/astaxie/beego/logs”

        配置log组件
            config := make(map[string]interface{})
            config["filename"] = "./logs/logcollect.log"
            config["level"] = logs.LevelDebug

            configStr, err := json.Marshal(config)
            if err != nil {
                fmt.Println("marshal failed, err:", err)
                return
            }
    
        初始化日志组件
            logs.SetLogger(“file”, string(configStr))

        package main

        import (
            "encoding/json"
            "fmt"
            "github.com/astaxie/beego/logs"
        )

        func main() {
            config := make(map[string]interface{})
            config["filename"] = "./logs/logcollect.log"
            config["level"] = logs.LevelDebug

            configStr, err := json.Marshal(config)
            if err != nil {
                fmt.Println("marshal failed, err:", err)
                return
            }

            logs.SetLogger(logs.AdapterFile, string(configStr))

            logs.Debug("this is a test, my name is %s", "stu01")
            logs.Trace("this is a trace, my name is %s", "stu02")
            logs.Warn("this is a warn, my name is %s", "stu03")
        }

配置文件热加载    Nginx热升级
    
日志收集客户端代码
    0
 
 
    
############################
go day 12

outline
    etcd
    ElasticSearch

etcd
    高可用的分布式key-value存储，可以用于配置共享和服务发现
    
    类似项目: zookeeper、 consul
    
    实现算法：基于raft算法的强一致性、高可用的服务存储目录
        强一致性和redis的主从同步不一样，主从同步可能存在同步延迟，主库更新了，从库还没更新

    使用场景
        1. 服务发现和服务注册
        2. 配置中心
        3. 分布式锁
        4. master选举
        
    etcd搭建
        a. etcd release 版本
        b. ./bin/etcd 启动etcd
        c. 使用etcdctl工具更改配置
        
context
    存全局都要调用的参数

    如何控制goroutine的超时？
        package main

        import (
            "context"
            "fmt"
            "io/ioutil"
            "net/http"
            "time"
        )
        type Result struct {
            r   *http.Response
            err error
        }
        func process() {
            ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
            defer cancel()
            tr := &http.Transport{}
            client := &http.Client{Transport: tr}
            c := make(chan Result, 1)
            req, err := http.NewRequest("GET", "http://www.baidu.com", nil)
            if err != nil {
                fmt.Println("http request failed, err:", err)
                return
            }
            go func() {
                resp, err := client.Do(req)
                pack := Result{r: resp, err: err}
                c <- pack
            }()
            select {
            case <-ctx.Done():
                tr.CancelRequest(req)
                res := <-c
                fmt.Println("Timeout! err:", res.err)
            case res := <-c:
                defer res.r.Body.Close()
                out, _ := ioutil.ReadAll(res.r.Body)
                fmt.Printf("Server Response: %s", out)
            }
            return
        }
        func main() {
            process()
        }

    如何保存上下文数据？ 
        func process(ctx context.Context) {
            ret,ok := ctx.Value("trace_id").(int)
            if !ok {
                ret = 21342423
            }

            fmt.Printf("ret:%d\n", ret)

            s , _ := ctx.Value("session").(string)
            fmt.Printf("session:%s\n", s)
        }

        func main() {
            ctx := context.WithValue(context.Background(), "trace_id", 13483434)
            ctx = context.WithValue(ctx, "session", "sdlkfjkaslfsalfsafjalskfj")
            process(ctx)
        }
    
定位调用链出现问题的地方   传一个tranceID   通过输出的日志来查询

etcd使用示例
    import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/coreos/etcd/clientv3"
    )

    const (
        EtcdKey = "/oldboy/backend/logagent/config/192.168.14.4"
    )

    type LogConf struct {
        Path  string `json:"path"`
        Topic string `json:"topic"`
    }


    func main() {
        EtcdExmaple()
    }

    func EtcdExmaple() {
        cli, err := clientv3.New(clientv3.Config{
            Endpoints:   []string{"localhost:2379", "localhost:22379", "localhost:32379"},
            DialTimeout: 5 * time.Second,
        })
        if err != nil {
            fmt.Println("connect failed, err:", err)
            return
        }

        fmt.Println("connect succ")
        defer cli.Close()

        ctx, cancel := context.WithTimeout(context.Background(), time.Second)
        _, err = cli.Put(ctx, "/logagent/conf/", "sample_value")
        cancel()
        if err != nil {
            fmt.Println("put failed, err:", err)
            return
        }

        ctx, cancel = context.WithTimeout(context.Background(), time.Second)
        resp, err := cli.Get(ctx, "/logagent/conf/")
        cancel()
        if err != nil {
            fmt.Println("get failed, err:", err)
            return
        }
        for _, ev := range resp.Kvs {
            fmt.Printf("%s : %s\n", ev.Key, ev.Value)
        }
    }

    https://golang.org/pkg/context/#example_WithCancel
        contex模式，主线程通知其他的goroutine退出
        
        package main

        import (
            "context"
            "fmt"
        )

        func main() {
            type favContextKey string

            f := func(ctx context.Context, k favContextKey) {
                if v := ctx.Value(k); v != nil {
                    fmt.Println("found value:", v)
                    return
                }
                fmt.Println("key not found:", k)
            }

            k := favContextKey("language")
            ctx := context.WithValue(context.Background(), k, "Go")

            f(ctx, k)
            f(ctx, favContextKey("color"))

        }
    
    https://golang.org/pkg/context/#pkg-examples
        WithCancel
        WithDeadline
        WithTimeout
        WithValue   
    
看etcd的配置有两种方式
    1. 轮询去查
    2. 等etcd通知
        import (
            "context"
            "fmt"
            "time"

            "github.com/coreos/etcd/clientv3"
        )

        func main() {

            cli, err := clientv3.New(clientv3.Config{
                Endpoints:   []string{"localhost:2379", "localhost:22379", "localhost:32379"},
                DialTimeout: 5 * time.Second,
            })
            if err != nil {
                fmt.Println("connect failed, err:", err)
                return
            }

            fmt.Println("connect succ")
            defer cli.Close()

            cli.Put(context.Background(), "/logagent/conf/", "8888888")
            for {
                rch := cli.Watch(context.Background(), "/logagent/conf/")     // 阻塞在这里，如果etcd中有变化的话才会返回
                for wresp := range rch {
                    for _, ev := range wresp.Events {
                        fmt.Printf("%s %q : %q\n", ev.Type, ev.Kv.Key, ev.Kv.Value)
                    }
                }
            }
        }
    
sync.WaitGroup
    主线程和goroutine的退出协调
        1. 主线程sleep() 等goroutine
        2. 用channel，每个goroutine传一个channel进去，goroutine执行完之后往chanel里面写东西
        3. contex模式，主线程通知其他的goroutine退出
        4. WaitGroup模式，goroutine做完事情后通知主线程
    
    sync.WaitGroup介绍
        1. 等待一组goroutine结束
        2. 使用Add方法设置等待的数量加1
        3. 使用Done方法设置等待的数量减一
        4. 当等待的数量等于0时，Wait函数返回
        
        func main() {
            wg := sync.WaitGroup{}

            for i := 0; i < 10; i++ {
                wg.Add(1)
                go calc(&wg, i)
            }

            wg.Wait()
            fmt.Println("all goroutine finish")
        }
        func calc(w *sync.WaitGroup, i int) {

            fmt.Println("calc:", i)
            time.Sleep(time.Second)
            w.Done()
        }
    
kafka消费示例
    import (
        "fmt"
        "strings"
        "sync"

        "github.com/Shopify/sarama"
    )

    var (
        wg sync.WaitGroup
    )

    func main() {

        consumer, err := sarama.NewConsumer(strings.Split("192.168.14.4:9092", ","), nil)
        if err != nil {
            fmt.Println("Failed to start consumer: %s", err)
            return
        }
        partitionList, err := consumer.Partitions("nginx_log")
        if err != nil {
            fmt.Println("Failed to get the list of partitions: ", err)
            return
        }
        fmt.Println(partitionList)
        for partition := range partitionList {
            pc, err := consumer.ConsumePartition("nginx_log", int32(partition), sarama.OffsetNewest)
            if err != nil {
                fmt.Printf("Failed to start consumer for partition %d: %s\n", partition, err)
                return
            }
            defer pc.AsyncClose()
            go func(pc sarama.PartitionConsumer) {
                wg.Add(1)
                for msg := range pc.Messages() {
                    fmt.Printf("Partition:%d, Offset:%d, Key:%s, Value:%s", msg.Partition, msg.Offset, string(msg.Key), string(msg.Value))
                    fmt.Println()
                }
                wg.Done()
            }(pc)
        }
        //time.Sleep(time.Hour)
        wg.Wait()
        consumer.Close()
    }

go的有些库有版本号，import的时候取一个别名，当版本变化之后代码不用改

链式操作通过函数返回对象的方式来实现
    type Stu struct {
        Name string
        Age  int
    }

    func (p *Stu) SetName(name string) *Stu {
        p.Name = name
        return p
    }

    func (p *Stu) SetAge(age int) *Stu {
        p.Age = age
        return p
    }

    func (p *Stu) Print() {
        fmt.Printf("age:%d name:%s\n", p.Age, p.Name)
    }

    func main() {
        stu := &Stu{}
        stu.SetAge(12).SetName("stu01").Print()
        //stu.SetName("stu01")
        //stu.Print()
    }

ES
    import (
        "fmt"
        elastic "gopkg.in/olivere/elastic.v2"
    )

    type Tweet struct {
        User    string
        Message string
    }

    func main() {
        client, err := elastic.NewClient(elastic.SetSniff(false), elastic.SetURL("http://192.168.31.177:9200/"))
        if err != nil {
            fmt.Println("connect es error", err)
            return
        }

        fmt.Println("conn es succ")

        tweet := Tweet{User: "olivere", Message: "Take Five"}
        _, err = client.Index().
            Index("twitter").
            Type("tweet").
            Id("1").
            BodyJson(tweet).
            Do()
        if err != nil {
            // Handle error
            panic(err)
            return
        }

        fmt.Println("insert succ")
    }

jrpc
    接口定义语言
    
    可以通过接口描述文件生成go、c++、java的代码



############################
go day 13 14

首先初始化配置文件(github.com/astaxie/beego/config)，然后初始化日志文件(github.com/astaxie/beego/logs)

metronic模板

Outline
    1. ElasticSearch介绍与使用
    2. kibana介绍与使用

mysql事务

Beego web开发

电商架构
    端：PC主站、M站、android/ios
    后台：购物车、订单、商品、库存、支付、优惠券
    数据库：MySQL、Redis、Hbase

秒杀抢购1.0   php + mysql + 代码耦合
    和已有电商逻辑重度耦合
    
    资源共享，缺乏隔离
        可以把当前的业务放到单独的集群上面
        
    服务缺乏限流和过载保护
        把超过上限的请求拒绝了，这样能提供有限的服务，不会所有的服务都挂了都先是404
        
    MYSQL存在性能瓶颈
        MySQL加锁，它的更行会非常慢。
        
    系统缺乏降级措施，不能及时恢复
        例如降级预案：如果抢购有问题了，迅速关掉秒杀模块。将用户的访问都统一返回一个抢购停止的静态页面，这样流量压力就不会到真实的服务器上去了，让其他的功能快速地恢复正常
        
    对雪崩缺乏深刻的认识
        一个小模块有问题，整个系统都挂掉了。不是秒杀模块的服务也挂了！其他所有不参加活动的商品都不能卖了

    弹性扩缩容
        高峰期用多点机器来抗，过了高峰期就可以回收这些资源。用docker来做

没有一个系统一下子做出来就是非常NB，什么问题也没有，能够满足所有需求，这样的系统是不存在的，无论你是多NB。这个东西都是通过一步一步的完善的。linux内核最初就是两万行代码，相当于能跑的一个demo，通过20多年的迭代更新，演进成了一个非常稳定的一个商业的产品。

秒杀抢购2.0优势
    代码和部署完全隔离，避免相互影响
        抢购模块在抢到之后，会生成一个token，然后带着这个token302重定向到电商网站，实现代码和部署完全隔离
        
    根据后端承载能力，进行限流，防止全网挂掉
    
    平台化，所有操作在web平台实时生效
    
    使用Redis承载海量QPS
        一个redis的QPS大概是15万左右
    
    整个系统采用Go重新开发，极大地提高了系统的性能
        10台php写的服务，服务器只能承载2万QPS，10台go写的服务，服务器只能承载2万QPS，

秒杀抢购3.0
    架构设计
        系统解耦       
        过载保护       
        降级预案
    
    模块划分
        秒杀接入
            长连接、ip黑名单、抢购开关、url校验、refer白名单、id黑名单 
        秒杀逻辑
        web平台

 

############################
go day 15

Outline
    1. 秒杀抢购接入层实现
    2. 秒杀逻辑层实现
    
秒杀接入层核心功能
    配置项
        etcd配置、超时时间、等待时间、token密钥、前端延迟、是否验证uid
    
    hdinfo
        强制售罄、活动未开始、活动已结束、售罄、正常状态


   
############################
go day 16

Outline
    1. 秒杀逻辑层的实现
    2. 接入层和逻辑层整合

业务核心层
    配置项
        redis配置
        etcd配置
        等级配置
        速度配置
        goroutine
        概率配置
        
    逻辑
        是否售罄
        是否超速
        是否已经购买
        是否总数超限
        是否黑名单
        随机抽奖
        更新速度
        更新进度
        
        

############################
go day 17

Outline
    1. 秒杀管理平台实现
    2. 平台测试和调试

平台核心功能
    商品添加
    商品浏览
    强制售罄
    商品修改
    

































































