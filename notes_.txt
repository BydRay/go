#############################
go 老男孩教育Go语言第一期



#############################
why go

day 1
    go 静态编译，不需要在运行时判断变量的类型，强类型语言的优势

    编译要求{要跟在函数后面，不能另起一行，阅读方便

    存在未使用的变量或未使用的包，则编译不通过，减少冗余代码，降低代码维护成本

    内存自动回收，只需要new分配内存，不需要释放

    从语言层面支持并发，并发编程简单



#############################
day 1

搭建开发环境

vs插件安装
    https://www.jianshu.com/p/be432e57acd2

nginx  强调多进程的架构
redis  单进程单线程的架构    服务器就需要多起几个实例

go 静态编译，不需要在运行时判断变量的类型，强类型语言的优势

编译要求{要跟在函数后面，不能另起一行，阅读方便

存在未使用的变量或未使用的包，则编译不通过，减少冗余代码，降低代码维护成本

内存自动回收，只需要new分配内存，不需要释放

从语言层面支持并发，并发编程简单

其他语言要写一个高并发的服务，就必须以维护一个线程池，go不需要，go的线程更轻量化，且go自己维护一个线程池

go 的并发基于CSP（Communicating Sequential Process）模型实现
    CSP理解：多个goroute之间通过channel进行通信，每个goroute都是轻量级高性能的

命令行 gofmt -w file.go   规范化代码，解决缩进、空行什么的

go 可以一个函数返回多个值，c 不可以

包的概念
    1. 和python一样，把相同功能的代码放到一个目录，称之为包
    2. 包可以被其他包引用
    3. main包是用来生成可执行文件，每个程序只有一个main包
    4. 包的主要用途是提高代码的可复用性

go 的编码永远都是utf-8

环境变量GOPATH用于指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作区，可以在GOPATH中设置多个工作区

go 开发目录结构
    d:/project/src/go_dev/day1/example1/hello.go
              /bin/
              /vender/        // 第三方包
              /pkg/           // 静态库
    export GOPATH=d:/project/

构建 
    C:\Users\user\Desktop\go\project> go build -o bin/hello.exe dev/day1/hello
    go build 默认到src下面区找，所以go build 输入路径不用在前面加上src
    
go run file.go   类似执行一个脚本获取结果

 


#############################
go day 2 

go 编译，包名未main，有func main()，则编译生成可执程序，否则生成lib库

go 编译性语言，任何执行语句不能放在函数体之外，这是编译型语言和解释性语言的一个重要区别
    var name string
    name = "xxx"
    编译报错，需要写个函数，到函数里面去初始化

包别名
    import(
        a  "add"
    )
    import(
        _  "add"       //仅导入这个包，不引用里面的任何一个变量和函数，这么做可以通过编译
    )
 
每个源文件都可以包含一个init函数，这个init函数自动被go运行框架调用。

常量使用const 修饰，代表永远是只读的，不能修改。
    const 只能修饰boolean，number（int相关类型、浮点类型、complex）和string
    const identifier [type] = value，其中type可以省略。
        const a string = "xxx"
        const b = "xxx"    
        const c = 9/3 
        const (
            a string = "xxx"
            b = "xxx"    
            c = 9/3 
        )

var(
    a int      // 默认为0
    b string   // 默认为“”
    c bool     // 默认为false
    d = 8
    e = "hello"   // 没类型也行，默认做类型推导
)
        
值类型：基本数据类型int、float、bool、string以及数组和struct。 值类型的内存通常在栈中分配。
引用类型：指针、slice、map、chan等都是引用类型。  引用类型的内存通常在堆上分配。

栈，如执行到一条函数语句，则先用栈保存传入的参数，然后跳到函数的地址，然后再将参数出栈，go 的栈空间一般是几K
堆  物理内存，需要动态申请，用完要释放，多个线程共用，需要加锁，分配性能没有栈高

变量作用域 块作用域

数字类型，主要有int、int8、int16、int32、int64、uint8、uint16、uint32、uint64、float32、float64
    var a float   // 出错

字符类型：var a byte    字符用‘’

字符串表示两种方式： 1）“”双引号    2）``（反引号） 原生字符串

https://go-zh.org/pkg/     // 官网package

打印占位符
    General：
        %v    相应值的默认格式。在打印结构体时，“加号”标记（%+v）会添加字段名
        %T    相应值的类型的Go语法表示
    Integer
        %c  相应Unicode码点所表示的字符   Printf("%c", 0x4E2D)    中
        %q    单引号围绕的字符字面值，由Go语法安全地转义 Printf("%q", 0x4E2D)        '中'
        %b    二进制表示    Printf("%b", 5)    101
    浮点数和复数的组成部分（实部和虚部）
        %f    有小数点而无指数，例如 123.456        Printf("%f", 10.2)     10.200000
        %g    根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf("%g", 10.20)   10.2
    字符串与字节切片
        %x    十六进制，小写字母，每字节两个字符      Printf("%x", "golang")         676f6c616e67
    指针
        %p  十六进制表示，前缀 0x    Printf("%p", &people)    0x4f57f0
    
str := fmt.Sprintf("a=%d", a)

len()  // 时间复杂度O(1)，字符串的长度默认是存起来的，C是要找到‘\0’

浏览器敲网址到看到页面的全过程  讲师的理解  很细节



#############################
go day 3

fmt.Scanf("%d%d", &n, &m)    // 终端输入时默认空格分隔

strings和strconv使用
    strings.HasPrefix(s string, prefix string) bool             // 判断字符串s是否以prefix开头。
    strings.HasSuffix(s string, suffix string) bool             // 判断字符串s是否以suffix结尾。
    strings.Index(s string, str string) int                     // 判断str在s中首次出现的位置，如果没有出现，则返回-1
    strings.LastIndex(s string, str string) int                 // 判断str在s中最后出现的位置，如果没有出现，则返回-1
    strings.Replace(str string, old string, new string, n int)  // 字符串替换
    strings.Count(str string, substr string)int                 // 字符串计数
    strings.Repeat(str string, count int)string                 // 重复count次str
    strings.ToLower(str string)string                           // 转为小写
    strings.ToUpper(str string)string                           // 转为大写
    strings.TrimSpace(str string)                               // 去掉字符串首尾空白字符
    strings.Trim(str string, cut string)                        // 去掉字符串首尾cut字符
        strings.Trim("abbacba", "ab") // => "c"
    strings.TrimLeft(str string, cut string)                    // 去掉字符串首cut字符
    strings.TrimRight(str string, cut string)                   // 去掉字符串尾cut字符
    strings.Fields(str string)                                   // 返回str空格分隔的所有子串的slice
    strings.Split(str string, split string)                     // 返回str被split分隔的所有子串的slice
    strings.Join(s1 []string, sep string)                       // 用sep把s1中的所有元素链接起来
        fmt.Println(strings.Join([]string{"a", "b", "c"}, ","))  
        // => "a,b,c"
    strconv.Itoa(i int)                                         // 把一个整数i转成字符串   相对于下面，不存在error
    strconv.Atoi(str string)(int, error)                        // 把一个字符串转成整数  返回一个error 对象 

时间和日期类型
    time.Time类型，用来表示时间
    获取当前时间， now := time.Now()
    time.Now().Minute()，time.Now().Day()，time.Now().Month()，time.Now().Year()
    time。Now().UnixNano()     // 1970年1月1日UTC以来经过的纳秒数。  
    time.Duration用来表示纳秒 
    const (
        Nanosecond  Duration = 1
        Microsecond          = 1000 * Nanosecond
        Millisecond          = 1000 * Microsecond
        Second               = 1000 * Millisecond
        Minute               = 60 * Second
        Hour                 = 60 * Minute
    )
    格式化：
        now := time.Now()
        fmt.Println(now.Format(“02/1/2006 15:04”))
        fmt.Println(now.Format(“2006/1/02 15:04”))
        fmt.Println(now.Format(“2006/1/02”))

指针类型

流程控制
    如果switch没有表达式，它会匹配true。
    Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码，fallthrough不会判断下一条case的expr结果是否为true。

    for i := 0; i < 5; i++ {}    // 注意没有 ()
    
    goto 和 label 语句
        func main() {
        LABEL1:
            for i := 0; i <= 5; i++ {
                for j := 0; j <= 5; j++ {
                    if j == 4 {
                        continue LABEL1    // 或者 goto LABEL1
                    }
                    fmt.Printf("i is: %d, and j is: %d\n", i, j)
                }
            }
        }
    
go 中英文都是utf-8编码，英文占1个字节，中文占3个字节

函数
    不支持重载，一个包不能有两个名字一样的函数

    函数也是一种类型一个函数可以赋值给变量
    
    匿名函数
    
    多返回值
    
    值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。

    命名返回值的名字
        func calc(a, b int) (sum int, avg int) {
            sum = a + b
            avg = (a +b)/2
            return
        }

    _标识符，用来忽略返回值

    可变参数：
        func add(arg ...int) int {}            // 0个或多个参数

        func add(a int, arg ...int) int {}  // 1个或多个参数

        其中arg是一个slice，我们可以通过arg[index]依次访问所有参数，通过len(arg)来判断传递参数的个数

    defer
        1. 当函数返回时，执行defer语句。因此，可以用来做资源清理
        2. 多个defer语句，按先进后出的方式执行
        3. defer语句中的变量，在defer声明时就决定了。
            func a() {
                i := 0
                defer fmt.Println(i)    // 输出 0
                i++
                return
            } 
        用途
            1. 关闭文件句柄
                func read() {
                    file := open(filename)
                    defer file.Close()
                    // 文件操作
                }
            2. 锁资源释放
                func read() {
                    mc.Lock()
                    defer mc.Unlock()
                    // 其他操作
                }
            3. 数据库连接释放
                func read() {
                    conn := openDatabase()
                    defer conn.Close()
                    // 其他操作
                }

                
            
############################
go day 4 

homework
    当字符串中有中英文时，rang str 返回的类型是int  int32，下标不一定是连续的
        str := "a2啊是"
        fmt.Println("len ", len(str))
        for i, v := range str {
            // fmt.Printf("%T-%T\n", i, v)   // int-int32
            fmt.Printf("%v  %c\n", i, v)
        }
            =>  len  8
                0  a
                1  2
                2  啊
                5  是
            
    rune数据类型   //int32的别名
        str := "a2啊是"
        t := []rune(str)             // 有中英文的字符串按照一个字符存4个字节，在utf-8中，中文3个字节，英文、数字一个字节
        fmt.Println(len(t))
        for i := 0; i < len(t); i++ {
            fmt.Printf("%d - %c - %x\n", i, t[i], t[i])
        }
            =>  4
                0 - a - 61
                1 - 2 - 32
                2 - 啊 - 554a
                3 - 是 - 662f

    bufio package
        reader := bufio.NewReader(os.Stdin)
        result, _, err  := reader.ReadLine()
        if err != nil {
            fmt.Println("read from console err:", err)
            return
        }

Outline
    1. 内置函数、递归函数、闭包
    2. 数组与切片
    3. map数据结构
    4. package介绍

内置函数
    1. close：主要用来关闭channel
    
    2. len：用来求长度，比如string、array、slice、map、channel
    
    3. new：用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针
    
    4. make：用来分配内存，主要用来分配引用类型，比如chan、map、slice
    
    5. append：用来追加元素到数组、slice中
        var a []int 
        a = append(a, 10)
        a = append(a, a...)  //   arg ...int 可变参数  这里表示将切片展开
        
    6. panic和recover：用来做错误处理
        func initConfig() (err error) {
            return errors.New("init config failed")
        }
        func test() {
            defer func() { 
                if err := recover(); err != nil {        // recover() 捕获异常,让程序继续运行，如果不捕获，有错误的话，整个程序就都挂了
                    fmt.Println(err)      // 可以查一下，打印出当前的错误堆栈，会显示出错代码具体行数  
                }
            }()
            
            err := initConfig()
            if err != nil {
                panic(err)       // 主动抛出异常
            }
            return
        }

    7. new和make的区别
        new 返回的是指针，make 直接返回的是一个数据类型
    
递归函数
    
闭包：一个函数和与其相关的引用环境组合而成的实体
    func Adder() func(int) int {
        var x int
        return func(delta int) int {
            x += delta
            return x
        } 
    }
    func main() {
        var f = Adder()
        fmt.Print(f(1))   // => 1
        fmt.Print(f(20))  // => 21
        fmt.Print(f(300)) // => 321
    } 

数组
    数组：是同一种数据类型的固定长度的序列。
    
    长度是数组类型的一部分，因此，var a[5] int和var a[10]int是不同的类型

    数组是值类型，因此改变副本的值，不会改变本身的值
        var arr1 [5]int
        arr2 := arr1
        arr2[2] = 100    // arr1 不会改变

    数组是定长的   切片是不定长的
    
    1. 数组初始化
        a. var age0 [5]int = [5]int{1,2,3}       // 后面的默认为0
        b. var age1 = [5]int{1,2,3,4,5}          // 自动类型推导
        c. var age2 = [...]int{1,2,3,4,5,6}      // ... 的第三个作用：自动数有几个元素
        d. var str = [5]string{3:”hello world”, 4:”tom”}         // 还可以指定下标初始化
    
    2. 多维数组
        a. var age [5][3]int
        b. var f [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}}

切片
    切片：切片是数组的一个引用，因此切片是引用类型
    
    切片的长度可以改变，因此，切片是一个可变的数组
    
    切片遍历方式和数组一样，可以用len()求长度
    
    cap可以求出slice最大的容量，0 <= len(slice) <= cap(array)，其中array是slice引用的数组    
    
    切片的定义：var 变量名 []类型，比如 var str []string  var arr []int

    通过make来创建切片  也可以通过已经定义的数组来创建
        var slice []type = make([]type, len)
        slice  := make([]type, len)
        slice  := make([]type, len, cap)       // 在不声明 cap 的情况下，默认 cap=len
        
    当对切片进行 append 操作，导致长度超出容量时，就会创建新的数组，这会导致和原有切片的分离。

    拷贝
        var a []int = []int{1, 2, 3, 4, 5, 6}
        b := make([]int, 1)
        copy(b, a)
        fmt.Println(b)    //   => [1]  没有报错，拷贝不会像append 一样去扩容
    
    string与slice
        string底层就是一个byte的数组，因此，也可以进行切片操作

    如何改变string中的字符值？string本身是不可变的，因此要改变string中字符，需要如下操作：
        str := “hello world 中国”
        s := []rune(str)    //  s := []byte(str) 处理中文有问题
        s[0] = ‘o’
        str = string(s)

数组与切片的排序    sort   package 
    sort.Ints   sort.Strings  sort.Float64  

    sort.SearchInts(a []int, b int)               //从切片a中查找b，默认返回的是从小到大排序后再查找的下标
    sort.SearchFloats(a []float64, b float64)    
    sort.SearchStrings(a []string, b string)      

map    key-value的数据结构，又叫字典或关联数组
    声明
        var map1 map[keytype]valuetype      //  声明是不会分配内存的，初始化需要make
        
        a := make(map[string]map[string]string, 100)
        a["key1"] = make(map[string]string)       // make 只能初始化第一层，第二层不初始化下面的赋值会panic
        a["key1"]["key2"] = "abc"
    
    map相关操作
        初始化
            var a map[string]string = map[string]string{“hello”: “world”}  
            a = make(map[string]string, 10)      // 超出容量时会自动扩容，但尽量提供一个合理的初始值
            cap(a)    // cap: 返回的是数组切片分配的空间大小, 根本不能用于map
            
        插入和更新
            a[“hello”] = “world”

        查找
            val, ok := a[“hello”]
        
        遍历
            for k, v := range a {
                fmt.Println(k,v)
            }
        
        删除
            delete(a, “hello”)   //  删除整个map 可以for循环，也可以重新 make 一个

        长度
            len(a)

        用map 和slice 之前一定要判断又没有初始化，没有初始化就用会panic

        map排序    map 默认是无序的，原因之一：开发者认为，如果是有序的，线上的程序依赖这个排序来处理业务逻辑，假如有一天go 的代码有问题，则整个业务都崩了，解耦合，想要有序，自己再处理
            先获取所有key，把key进行排序，然后按照排序好的key，进行遍历
                var a map[int]int
                a = make(map[int]int, 5)
                var keys []int
                for k, _ := range a {
                    keys = append(keys, k)
                }
                sort.Ints(keys)
                for _, v := range keys {
                    fmt.Println(v, a[v])
                }
        
        map反转
            初始化另外一个map，把key、value互换即可

package 
    
线程同步
    import(“sync”)
        var mu sync.Mutex     // 互斥锁, 无论是读还是写协程，同时只能有一个协程在操作
        mu.Lock()
        mu.Unlock()
        
        var mu sync.RWMutex   // 读写锁, 读锁的时候，可以有多个读的协程在操作    读多写少的情况下使用，性能高
        mu.Lock()    // 写锁操作
        mu.Unlock()
        mu.RLock()   // 读锁操作
        mu.RUnlock()
    
    go build -race    // 编译的时候检查是否有用锁出错的地方

原子操作    
    atomic.AddInt32(&count, 1)    // 使多个协程对count处理时逻辑上正确，count 加1时是串行的
    atomic.LoadInt32(&count)
    
go get安装第三方包



############################
go day 5

Outline
    1. 结构体和方法
    2. 接口
    3. 课后作业

Go中的struct
    1. 用来自定义复杂数据结构
    2. struct里面可以包含多个字段（属性）
    3. struct类型可以定义方法，注意和函数的区分
    4. struct类型是值类型
    5. struct类型可以嵌套
    6. Go语言没有class类型，只有struct类型    // 和其他语言的重要区别

    声明
        type 标识符 struct {
               field1 type
               field2 type
        }

    struct 中字段访问：和其他语言一样，使用.

    struct定义的三种形式：
        var stu Student
        var stu *Student = new (Student)
        var stu *Student = &Student{}

    访问形式   
        stu.Name         // stu 是指针类型也行，go 会自动转成(*stu).Name
        (*stu).Name

    struct的内存布局：struct中的所有字段在内存是连续的
        type Student struct {
            Name  string
            Age   int
            score float32
        }
        
        stu.Name = "hua"
        stu.Age = 18
        stu.score = 80

        fmt.Printf("Name:%p\n", &stu.Name)
        fmt.Printf("Age: %p\n", &stu.Age)
        fmt.Printf("score:%p\n", &stu.score)
            
        =>  
        Name:0xc000004480
        Age: 0xc000004490           // “hua” 占用 10 字节？ 
        score:0xc000004498          // int 占用 8 字节     利用“struct中的所有字段在内存是连续的”来计算int占用的字节数

    链表定义
        type Student struct {
               Name string
               Next* Student
        }

    双链表定义
        type Student struct {
               Name string
               Next* Student
               Prev* Student
        }

    二叉树定义
        type Student struct {
               Name string
               left* Student
               right* Student
        }

    别名
        type Student struct {
            Number int
        }
        type Stu Student   
        var a Student, b stu    
        a = b    //  不能赋值，虽然有相同的字段，但是属于不同的类型
        
    golang中的struct没有构造函数，一般可以使用工厂模式来解决这个问题     ？工厂模式

    make 用来创建map、slice、channel    new用来创建值类型

    我们可以为struct中的每个字段，写上一个tag。这个tag可以通过反射的机制获取到，最常用的场景就是json序列化和反序列化     ？后面讲

    
    匿名字段    结构体中字段可以没有名字
        type Car struct {
            Name stirng
            Age int        
        }
        type Train struct {
            Car
            Start time.Time
            int
        }

    方法
        Golang中的方法是作用在特定类型的变量上，因此自定义类型，都可以有方法，而不仅仅是struct
        
        定义：func (recevier type) methodName(参数列表)(返回值列表){}

        方法和函数的调用区别
            函数：function(variable, 参数列表）
            方法：variable.function(参数列表）

        方法的访问控制，通过大小写控制

        调用方法时，
            type integer int
            func (p *integer) set(b integer) {
                *p = b
            }
            var a integer
            a = 100
            a.set(1000)    //  不用写成(*a).set(1000)  go 会自动转化
    
    继承   组合
        如果一个struct嵌套了另一个匿名结构体，那么这个结构可以直接访问匿名结构体的方法，从而实现了继承。
    
        如果一个struct嵌套了另一个有名结构体，那么这个模式就叫组合。

        多重继承
            如果一个struct嵌套了多个匿名结构体，那么这个结构可以直接访问多个匿名结构体的方法，从而实现了多重继承。

接口
    Interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。

    定义
        type example interface{
            Method1(参数列表) 返回值列表
            Method2(参数列表) 返回值列表
            …
        }

    interface类型默认是一个指针

    接口实现
        Golang中的接口，不需要显示的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。

    多态
        一个接口，多种实现

    接口嵌套
        type ReadWrite interface {
            Read(b Buffer) bool
            Write(b Buffer) bool
        } 
        type Lock interface {
            Lock()
            Unlock() 
        } 
        type File interface {
            ReadWrite
            Lock 
            Close() 
        } 
    



















 

